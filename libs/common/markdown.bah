#include "iostream.bah"
#include "string.bah"

//An internal function used to append the array of chars b to the array a.
appendCharArr(a []char, b []char) {
    offset = len(a)
    lenB = len(b)
    i=0; for i < lenB {
        a[offset+i] = b[i]
        i = i + 1
    }
}

//An internal structure to define a single line of markdown by its type.
struct markdownLine {
    line: string*
    type: int = 0
}

//A wrapper for the markdown parser.
struct markdown {

    lines: []markdownLine*

    //To retreive the document as lines without transpilling it to any other language.
    //This is mainly for debugging/verbose purposes.
    str() cpstring {
        s = string("")
        i=0;for i < len(this.lines) {
            mdl = this.lines[i]
            l = intToString(i)
            l.append(": ")
            l.append(mdl.line)
            l.append("\n")
            s.append(l)
            i++
        }

        r = s.str()
        return r
    }

    //To transpille your markdown document as a html document.
    //This will return a cpstring containning your markdown document as html code.
    html() cpstring {
        html = string("<p>")

        i=0;for i < len(this.lines) {
            mdl = this.lines[i]
            l = string(mdl.line)

            if mdl.type == 1 {
                l.prepend("<h1>")
                l.append("</h1>")
            } else if mdl.type == 2 {
                l.prepend("<h2>")
                l.append("</h2>")
            } else if mdl.type == 3 {
                l.prepend("<h3>")
                l.append("</h3>")
            } else if mdl.type == 4 {
                l.prepend("<h4>")
                l.append("</h4>")
            } else if mdl.type == 5 {
                l.prepend("<h5>")
                l.append("</h5>")
            } else if mdl.type == 6 {
                l.prepend("<h6>")
                l.append("</h6>")
            } else if mdl.type == 7 {
                l.prepend("&nbsp;â€¢ ")
                l.append("<br>")
            } else if mdl.type == 8 {
                l.prepend("    ")
            } else if mdl.type == 9 {
                l.prepend("<blockquote>")
                l.append("</blockquote>")
            } else {
                //l.prepend("<p>")
                l.append("</br>")
            }

            l.append("\n")
            html.append(l)

            i++
        }
        html.append("</p>")
        r = html.str()
        return r
    }

}

//An internal function to parse every inline element of a line.
//Inline elements are syntax features that do not impact the entire line.
//For instance, the bold delimiter is an inline feature, the hastag at the biginning of a line is not.
parseMarkdownInline(l string) string {
    nl = []char
    
    

    isBold = 0
    isItal = 0
    isUline = 0

    isImage = 0

    isLink = 0
    linkName = []char
    linkUrl = []char

    i=0;for i<l.length {
        c = l.charAt(i)

        //link
        if isLink == 1 {
            if c == ']' {
                isLink = 2
            } else {
                linkName[len(linkName)] = c
            }
            i++
            continue
        }
        if isLink == 2 {
            if c == '(' {
                isLink = 3
            }
            i++
            continue
        }
        if isLink == 3 {
            if c == ')' {
                if isImage {
                    appendCharArr(nl, strToArr("<img src=\""))
                    appendCharArr(nl, linkUrl)
                    appendCharArr(nl, strToArr("\" alt=\""))
                    appendCharArr(nl, linkName)
                    appendCharArr(nl, strToArr("\">"))
                    // nl.append("<img src=\"")
                    // nl.append(arrToStr(linkUrl))
                    // nl.append("\" alt=\"")
                    // nl.append(arrToStr(linkName))
                    // nl.append("\">")

                    isImage = 0
                } else {
                    appendCharArr(nl, strToArr("<a href=\""))
                    appendCharArr(nl, linkUrl)
                    appendCharArr(nl, strToArr("\">"))
                    appendCharArr(nl, linkName)
                    appendCharArr(nl, strToArr("</a>"))
                    // nl.append("<a href=\"")
                    // nl.append(arrToStr(linkUrl))
                    // nl.append("\">")
                    // nl.append(arrToStr(linkName))
                    // nl.append("</a>")
                }
                isLink = 0
                clear(linkName)
                clear(linkUrl)
            } else {
                linkUrl[len(linkUrl)] = c
            }
            i++
            continue
        }
        if c == '[' {
            validateState = 0
            ii=i;for ii<l.length {
                vc = l.charAt(ii)
                if validateState == 0 {
                    if vc == ']' {
                        validateState = 1
                    }
                } else if validateState == 1 {
                    if vc == '(' {
                        validateState = 2
                        ii++
                        continue
                    }
                    if isSpace(vc) == 0 {
                        validateState = 0
                    }
                } else if validateState == 2 {
                    if vc == ')' {
                        validateState = 3
                        break
                    }
                }
                ii++
            }
            if validateState == 3 {
                isLink = 1
                i++
                continue
            } else if isImage {
                isImage = 0
                nl[len(nl)] = '!'
                // nl.append("!")
            }
        }

        if c == '!' {
            nc = l.charAt(i+1)
            if nc == '[' {
                isImage = 1
            }
            i++
            continue
        }

        //bold
        if c == '*' {
            if l.charAt(i+1) == '*' {
            if isBold {
                appendCharArr(nl, strToArr("</strong>"))
                // nl.append("</strong>")
                isBold = 0
            } else {
                appendCharArr(nl, strToArr("<strong>"))
                // nl.append("<strong>")
                isBold = 1
            }
            i += 2
            continue
            } else {
        //italic
                if isItal {
                    appendCharArr(nl, strToArr("</em>"))
                    // nl.append("</em>")
                    isItal = 0
                } else {
                    appendCharArr(nl, strToArr("<em>"))
                    // nl.append("<em>")
                    isItal = 1
                }
                i++
                continue
            }
        }

        //underlining
        if c == '_' {
            if l.charAt(i+1) == '_' {
                if isUline {
                    appendCharArr(nl, strToArr("</u>"))
                    // nl.append("</u>")
                    isUline = 0
                } else {
                    appendCharArr(nl, strToArr("<u>"))
                    // nl.append("<u>")
                    isUline = 1
                }
                i += 2
                continue
            }
        }

        
        // nl.append(charToString(c))
        nl[len(nl)] = c
        i++
    }

    r = string(arrToStr(nl))

    return r
}

//To parse a markdown document.
//This will return a markdown structure that can be then transpilled into html.
parseMarkdown(a cpstring) markdown {
    md = string(a)
    lines = splitString(md, "\n")
    m = markdown{}
    
    i = 0; for i < len(lines) {
        l = lines[i]
        l.trim()
        l = parseMarkdownInline(l)
        nl = new string

        ml = new markdownLine

        if l.hasPrefix("# ") {
            ml.type = 1
            nl.set(l)
            nl.trimLeft(2)
        } else if l.hasPrefix("## ") {
            ml.type = 2
            nl.set(l)
            nl.trimLeft(3)
        } else if l.hasPrefix("### ") {
            ml.type = 3
            nl.set(l)
            nl.trimLeft(4)

        } else if l.hasPrefix("#### ") {
            ml.type = 4
            nl.set(l)
            nl.trimLeft(5)

        } else if l.hasPrefix("##### ") {
            ml.type = 5
            nl.set(l)
            nl.trimLeft(6)

        } else if l.hasPrefix("###### ") {
            ml.type = 6
            nl.set(l)
            nl.trimLeft(7)

        } else if l.hasPrefix("- ") {
            ml.type = 7
            nl.set(l)
            nl.trimLeft(2)
        } else if l.hasPrefix("> ") {
            ml.type = 9
            nl.set(l)
            nl.trimLeft(2)
        } else {

            if l.length > 0 {
                fc=l.charAt(0); if isNumber(fc) {
                    ml.type = 8
                }
            }
                nl.set(l)
            }
        
        ml.line = nl
        mll = len(m.lines)
        m.lines[mll] = ml
        
        i++
    }


    return m
}

//This escapes every character that the markdown parser could take as markdown code.
//It is not meant to be ran on your main markdown document but rather on some parts that you dont want to be taken as markdown.
escapeMarkdownHTML(s string*) {
    s.replace("*", "&ast;")
    s.replace(">", "&gt;")
    s.replace("__", "&#95;&#95;")
    s.replace("-", "&#45;")
    s.replace("#", "&#35;")
}

//Example
// #include "iostream.bah"
// #include "markdown.bah"
// main() {
// article = "# How to write Bah code?
//
// > It's not that hard
//
// Simply **smash** your keyboard
// "
// md = parseMarkdown(article)
// htmlCode = md.html()
// println(htmlCode)
// }